{"ts":1357929468606,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*!\n * socket.io-node\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , url = require('url')\n  , tty = require('tty')\n  , crypto = require('crypto')\n  , util = require('./util')\n  , store = require('./store')\n  , client = require('socket.io-client')\n  , transports = require('./transports')\n  , Logger = require('./logger')\n  , Socket = require('./socket')\n  , MemoryStore = require('./stores/memory')\n  , SocketNamespace = require('./namespace')\n  , Static = require('./static')\n  , EventEmitter = process.EventEmitter;\n\n/**\n * Export the constructor.\n */\n\nexports = module.exports = Manager;\n\n/**\n * Default transports.\n */\n\nvar defaultTransports = exports.defaultTransports = [\n    'websocket'\n  , 'htmlfile'\n  , 'xhr-polling'\n  , 'jsonp-polling'\n];\n\n/**\n * Inherited defaults.\n */\n\nvar parent = module.parent.exports\n  , protocol = parent.protocol\n  , jsonpolling_re = /^\\d+$/;\n\n/**\n * Manager constructor.\n *\n * @param {HTTPServer} server\n * @param {Object} options, optional\n * @api public\n */\n\nfunction Manager (server, options) {\n  this.server = server;\n  this.namespaces = {};\n  this.sockets = this.of('');\n  this.settings = {\n      origins: '*:*'\n    , log: true\n    , store: new MemoryStore\n    , logger: new Logger\n    , static: new Static(this)\n    , heartbeats: true\n    , resource: '/socket.io'\n    , transports: defaultTransports\n    , authorization: false\n    , blacklist: ['disconnect']\n    , 'log level': 3\n    , 'log colors': tty.isatty(process.stdout.fd)\n    , 'close timeout': 60\n    , 'heartbeat interval': 25\n    , 'heartbeat timeout': 60\n    , 'polling duration': 20\n    , 'flash policy server': true\n    , 'flash policy port': 10843\n    , 'destroy upgrade': true\n    , 'destroy buffer size': 10E7\n    , 'browser client': true\n    , 'browser client cache': true\n    , 'browser client minification': false\n    , 'browser client etag': false\n    , 'browser client expires': 315360000\n    , 'browser client gzip': false\n    , 'browser client handler': false\n    , 'client store expiration': 15\n    , 'match origin protocol': false\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      this.settings[i] = options[i];\n    }\n  }\n\n  var self = this;\n\n  // default error handler\n  server.on('error', function(err) {\n    self.log.warn('error raised: ' + err);\n  });\n\n  this.initStore();\n\n  this.on('set:store', function() {\n    self.initStore();\n  });\n\n  // reset listeners\n  this.oldListeners = server.listeners('request').splice(0);\n\n  server.on('request', function (req, res) {\n    self.handleRequest(req, res);\n  });\n\n  server.on('upgrade', function (req, socket, head) {\n    self.handleUpgrade(req, socket, head);\n  });\n\n  server.on('close', function () {\n    clearInterval(self.gc);\n  });\n\n  server.once('listening', function () {\n    self.gc = setInterval(self.garbageCollection.bind(self), 10000);\n  });\n\n  for (var i in transports) {\n    if (transports.hasOwnProperty(i)) {\n      if (transports[i].init) {\n        transports[i].init(this);\n      }\n    }\n  }\n\n  // forward-compatibility with 1.0\n  var self = this;\n  this.sockets.on('connection', function (conn) {\n    self.emit('connection', conn);\n  });\n\n  this.sequenceNumber = Date.now() | 0;\n \n  this.log.info('socket.io started');\n};\n\nManager.prototype.__proto__ = EventEmitter.prototype\n\n/**\n * Store accessor shortcut.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('store', function () {\n  var store = this.get('store');\n  store.manager = this;\n  return store;\n});\n\n/**\n * Logger accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('log', function () {\n  var logger = this.get('logger');\n\n  logger.level = this.get('log level') || -1;\n  logger.colors = this.get('log colors');\n  logger.enabled = this.enabled('log');\n\n  return logger;\n});\n\n/**\n * Static accessor.\n *\n * @api public\n */\n\nManager.prototype.__defineGetter__('static', function () {\n  return this.get('static');\n});\n\n/**\n * Get settings.\n *\n * @api public\n */\n\nManager.prototype.get = function (key) {\n  return this.settings[key];\n};\n\n/**\n * Set settings\n *\n * @api public\n */\n\nManager.prototype.set = function (key, value) {\n  if (arguments.length == 1) return this.get(key);\n  this.settings[key] = value;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Enable a setting\n *\n * @api public\n */\n\nManager.prototype.enable = function (key) {\n  this.settings[key] = true;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Disable a setting\n *\n * @api public\n */\n\nManager.prototype.disable = function (key) {\n  this.settings[key] = false;\n  this.emit('set:' + key, this.settings[key], key);\n  return this;\n};\n\n/**\n * Checks if a setting is enabled\n *\n * @api public\n */\n\nManager.prototype.enabled = function (key) {\n  return !!this.settings[key];\n};\n\n/**\n * Checks if a setting is disabled\n *\n * @api public\n */\n\nManager.prototype.disabled = function (key) {\n  return !this.settings[key];\n};\n\n/**\n * Configure callbacks.\n *\n * @api public\n */\n\nManager.prototype.configure = function (env, fn) {\n  if ('function' == typeof env) {\n    env.call(this);\n  } else if (env == (process.env.NODE_ENV || 'development')) {\n    fn.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Initializes everything related to the message dispatcher.\n *\n * @api private\n */\n\nManager.prototype.initStore = function () {\n  this.handshaken = {};\n  this.connected = {};\n  this.open = {};\n  this.closed = {};\n  this.rooms = {};\n  this.roomClients = {};\n\n  var self = this;\n\n  this.store.subscribe('handshake', function (id, data) {\n    self.onHandshake(id, data);\n  });\n\n  this.store.subscribe('connect', function (id) {\n    self.onConnect(id);\n  });\n\n  this.store.subscribe('open', function (id) {\n    self.onOpen(id);\n  });\n\n  this.store.subscribe('join', function (id, room) {\n    self.onJoin(id, room);\n  });\n\n  this.store.subscribe('leave', function (id, room) {\n    self.onLeave(id, room);\n  });\n\n  this.store.subscribe('close', function (id) {\n    self.onClose(id);\n  });\n\n  this.store.subscribe('dispatch', function (room, packet, volatile, exceptions) {\n    self.onDispatch(room, packet, volatile, exceptions);\n  });\n\n  this.store.subscribe('disconnect', function (id) {\n    self.onDisconnect(id);\n  });\n};\n\n/**\n * Called when a client handshakes.\n *\n * @param text\n */\n\nManager.prototype.onHandshake = function (id, data) {\n  this.handshaken[id] = data;\n};\n\n/**\n * Called when a client connects (ie: transport first opens)\n *\n * @api private\n */\n\nManager.prototype.onConnect = function (id) {\n  this.connected[id] = true;\n};\n\n/**\n * Called when a client opens a request in a different node.\n *\n * @api private\n */\n\nManager.prototype.onOpen = function (id) {\n  this.open[id] = true;\n\n  if (this.closed[id]) {\n    var self = this;\n\n    this.store.unsubscribe('dispatch:' + id, function () {\n      var transport = self.transports[id];\n      if (self.closed[id] && self.closed[id].length && transport) {\n\n        // if we have buffered messages that accumulate between calling\n        // onOpen an this async callback, send them if the transport is \n        // still open, otherwise leave them buffered\n        if (transport.open) {\n          transport.payload(self.closed[id]);\n          self.closed[id] = [];\n        }\n      }\n    });\n  }\n\n  // clear the current transport\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    this.transports[id] = null;\n  }\n};\n\n/**\n * Called when a message is sent to a namespace and/or room.\n *\n * @api private\n */\n\nManager.prototype.onDispatch = function (room, packet, volatile, exceptions) {\n  if (this.rooms[room]) {\n    for (var i = 0, l = this.rooms[room].length; i < l; i++) {\n      var id = this.rooms[room][i];\n\n      if (!~exceptions.indexOf(id)) {\n        if (this.transports[id] && this.transports[id].open) {\n          this.transports[id].onDispatch(packet, volatile);\n        } else if (!volatile) {\n          this.onClientDispatch(id, packet);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Called when a client joins a nsp / room.\n *\n * @api private\n */\n\nManager.prototype.onJoin = function (id, name) {\n  if (!this.roomClients[id]) {\n    this.roomClients[id] = {};\n  }\n\n  if (!this.rooms[name]) {\n    this.rooms[name] = [];\n  }\n\n  if (!~this.rooms[name].indexOf(id)) {\n    this.rooms[name].push(id);\n    this.roomClients[id][name] = true;\n  }\n};\n\n/**\n * Called when a client leaves a nsp / room.\n *\n * @param private\n */\n\nManager.prototype.onLeave = function (id, room) {\n  if (this.rooms[room]) {\n    var index = this.rooms[room].indexOf(id);\n\n    if (index >= 0) {\n      this.rooms[room].splice(index, 1);\n    }\n\n    if (!this.rooms[room].length) {\n      delete this.rooms[room];\n    }\n\n    if (this.roomClients[id]) {\n      delete this.roomClients[id][room];\n    }\n  }\n};\n\n/**\n * Called when a client closes a request in different node.\n *\n * @api private\n */\n\nManager.prototype.onClose = function (id) {\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  this.closed[id] = [];\n\n  var self = this;\n\n  this.store.subscribe('dispatch:' + id, function (packet, volatile) {\n    if (!volatile) {\n      self.onClientDispatch(id, packet);\n    }\n  });\n};\n\n/**\n * Dispatches a message for a closed client.\n *\n * @api private\n */\n\nManager.prototype.onClientDispatch = function (id, packet) {\n  if (this.closed[id]) {\n    this.closed[id].push(packet);\n  }\n};\n\n/**\n * Receives a message for a client.\n *\n * @api private\n */\n\nManager.prototype.onClientMessage = function (id, packet) {\n  if (this.namespaces[packet.endpoint]) {\n    this.namespaces[packet.endpoint].handlePacket(id, packet);\n  }\n};\n\n/**\n * Fired when a client disconnects (not triggered).\n *\n * @api private\n */\n\nManager.prototype.onClientDisconnect = function (id, reason) {\n  for (var name in this.namespaces) {\n    if (this.namespaces.hasOwnProperty(name)) {\n      this.namespaces[name].handleDisconnect(id, reason, typeof this.roomClients[id] !== 'undefined' &&\n        typeof this.roomClients[id][name] !== 'undefined');\n    }\n  }\n\n  this.onDisconnect(id);\n};\n\n/**\n * Called when a client disconnects.\n *\n * @param text\n */\n\nManager.prototype.onDisconnect = function (id, local) {\n  delete this.handshaken[id];\n\n  if (this.open[id]) {\n    delete this.open[id];\n  }\n\n  if (this.connected[id]) {\n    delete this.connected[id];\n  }\n\n  if (this.transports[id]) {\n    this.transports[id].discard();\n    delete this.transports[id];\n  }\n\n  if (this.closed[id]) {\n    delete this.closed[id];\n  }\n\n  if (this.roomClients[id]) {\n    for (var room in this.roomClients[id]) {\n      if (this.roomClients[id].hasOwnProperty(room)) {\n        this.onLeave(id, room);\n      }\n    }\n    delete this.roomClients[id]\n  }\n\n  this.store.destroyClient(id, this.get('client store expiration'));\n\n  this.store.unsubscribe('dispatch:' + id);\n\n  if (local) {\n    this.store.unsubscribe('message:' + id);\n    this.store.unsubscribe('disconnect:' + id);\n  }\n};\n\n/**\n * Handles an HTTP request.\n *\n * @api private\n */\n\nManager.prototype.handleRequest = function (req, res) {\n  var data = this.checkRequest(req);\n\n  if (!data) {\n    for (var i = 0, l = this.oldListeners.length; i < l; i++) {\n      this.oldListeners[i].call(this.server, req, res);\n    }\n\n    return;\n  }\n\n  if (data.static || !data.transport && !data.protocol) {\n    if (data.static && this.enabled('browser client')) {\n      this.static.write(data.path, req, res);\n    } else {\n      res.writeHead(200);\n      res.end('Welcome to socket.io.');\n\n      this.log.info('unhandled socket.io url');\n    }\n\n    return;\n  }\n\n  if (data.protocol != protocol) {\n    res.writeHead(500);\n    res.end('Protocol version not supported.');\n\n    this.log.info('client protocol version unsupported');\n  } else {\n    if (data.id) {\n      this.handleHTTPRequest(data, req, res);\n    } else {\n      this.handleHandshake(data, req, res);\n    }\n  }\n};\n\n/**\n * Handles an HTTP Upgrade.\n *\n * @api private\n */\n\nManager.prototype.handleUpgrade = function (req, socket, head) {\n  var data = this.checkRequest(req)\n    , self = this;\n\n  if (!data) {\n    if (this.enabled('destroy upgrade')) {\n      socket.end();\n      this.log.debug('destroying non-socket.io upgrade');\n    }\n\n    return;\n  }\n\n  req.head = head;\n  this.handleClient(data, req);\n};\n\n/**\n * Handles a normal handshaken HTTP request (eg: long-polling)\n *\n * @api private\n */\n\nManager.prototype.handleHTTPRequest = function (data, req, res) {\n  req.res = res;\n  this.handleClient(data, req);\n};\n\n/**\n * Intantiantes a new client.\n *\n * @api private\n */\n\nManager.prototype.handleClient = function (data, req) {\n  var socket = req.socket\n    , store = this.store\n    , self = this;\n\n  // handle sync disconnect xhrs\n  if (undefined != data.query.disconnect) {\n    if (this.transports[data.id] && this.transports[data.id].open) {\n      this.transports[data.id].onForcedDisconnect();\n    } else {\n      this.store.publish('disconnect-force:' + data.id);\n    }\n    req.res.writeHead(200);\n    req.res.end();\n    return;\n  }\n\n  if (!~this.get('transports').indexOf(data.transport)) {\n    this.log.warn('unknown transport: \"' + data.transport + '\"');\n    req.connection.end();\n    return;\n  }\n\n  var transport = new transports[data.transport](this, data, req)\n    , handshaken = this.handshaken[data.id];\n\n  if (transport.disconnected) {\n    // failed during transport setup\n    req.connection.end();\n    return;\n  }\n  if (handshaken) {\n    if (transport.open) {\n      if (this.closed[data.id] && this.closed[data.id].length) {\n        transport.payload(this.closed[data.id]);\n        this.closed[data.id] = [];\n      }\n\n      this.onOpen(data.id);\n      this.store.publish('open', data.id);\n      this.transports[data.id] = transport;\n    }\n\n    if (!this.connected[data.id]) {\n      this.onConnect(data.id);\n      this.store.publish('connect', data.id);\n\n      // flag as used\n      delete handshaken.issued;\n      this.onHandshake(data.id, handshaken);\n      this.store.publish('handshake', data.id, handshaken);\n\n      // initialize the socket for all namespaces\n      for (var i in this.namespaces) {\n        if (this.namespaces.hasOwnProperty(i)) {\n          var socket = this.namespaces[i].socket(data.id, true);\n\n          // echo back connect packet and fire connection event\n          if (i === '') {\n            this.namespaces[i].handlePacket(data.id, { type: 'connect' });\n          }\n        }\n      }\n\n      this.store.subscribe('message:' + data.id, function (packet) {\n        self.onClientMessage(data.id, packet);\n      });\n\n      this.store.subscribe('disconnect:' + data.id, function (reason) {\n        self.onClientDisconnect(data.id, reason);\n      });\n    }\n  } else {\n    if (transport.open) {\n      transport.error('client not handshaken', 'reconnect');\n    }\n\n    transport.discard();\n  }\n};\n\n/**\n * Generates a session id.\n *\n * @api private\n */\n\nManager.prototype.generateId = function () {\n  var rand = new Buffer(15); // multiple of 3 for base64\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\n      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  if (crypto.randomBytes) {\n    crypto.randomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function(i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Handles a handshake request.\n *\n * @api private\n */\n\nManager.prototype.handleHandshake = function (data, req, res) {\n  var self = this\n    , origin = req.headers.origin\n    , headers = {\n        'Content-Type': 'text/plain'\n    };\n\n  function writeErr (status, message) {\n    if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n      res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      res.end('io.j[' + data.query.jsonp + '](new Error(\"' + message + '\"));');\n    } else {\n      res.writeHead(status, headers);\n      res.end(message);\n    }\n  };\n\n  function error (err) {\n    writeErr(500, 'handshake error');\n    self.log.warn('handshake error ' + err);\n  };\n\n  if (!this.verifyOrigin(req)) {\n    writeErr(403, 'handshake bad origin');\n    return;\n  }\n\n  var handshakeData = this.handshakeData(data);\n\n  if (origin) {\n    // https://developer.mozilla.org/En/HTTP_Access_Control\n    headers['Access-Control-Allow-Origin'] = origin;\n    headers['Access-Control-Allow-Credentials'] = 'true';\n  }\n\n  this.authorize(handshakeData, function (err, authorized, newData) {\n    if (err) return error(err);\n\n    if (authorized) {\n      var id = self.generateId()\n        , hs = [\n              id\n            , self.enabled('heartbeats') ? self.get('heartbeat timeout') || '' : ''\n            , self.get('close timeout') || ''\n            , self.transports(data).join(',')\n          ].join(':');\n\n      if (data.query.jsonp && jsonpolling_re.test(data.query.jsonp)) {\n        hs = 'io.j[' + data.query.jsonp + '](' + JSON.stringify(hs) + ');';\n        res.writeHead(200, { 'Content-Type': 'application/javascript' });\n      } else {\n        res.writeHead(200, headers);\n      }\n\n      res.end(hs);\n\n      self.onHandshake(id, newData || handshakeData);\n      self.store.publish('handshake', id, newData || handshakeData);\n\n      self.log.info('handshake authorized', id);\n    } else {\n      writeErr(403, 'handshake unauthorized');\n      self.log.info('handshake unauthorized');\n    }\n  })\n};\n\n/**\n * Gets normalized handshake data\n *\n * @api private\n */\n\nManager.prototype.handshakeData = function (data) {\n  var connection = data.request.connection\n    , connectionAddress\n    , date = new Date;\n\n  if (connection.remoteAddress) {\n    connectionAddress = {\n        address: connection.remoteAddress\n      , port: connection.remotePort\n    };\n  } else if (connection.socket && connection.socket.remoteAddress) {\n    connectionAddress = {\n        address: connection.socket.remoteAddress\n      , port: connection.socket.remotePort\n    };\n  }\n\n  return {\n      headers: data.headers\n    , address: connectionAddress\n    , time: date.toString()\n    , query: data.query\n    , url: data.request.url\n    , xdomain: !!data.request.headers.origin\n    , secure: data.request.connection.secure\n    , issued: +date\n  };\n};\n\n/**\n * Verifies the origin of a request.\n *\n * @api private\n */\n\nManager.prototype.verifyOrigin = function (request) {\n  var origin = request.headers.origin || request.headers.referer\n    , origins = this.get('origins');\n\n  if (origin === 'null') origin = '*';\n\n  if (origins.indexOf('*:*') !== -1) {\n    return true;\n  }\n\n  if (origin) {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || 80;\n      var ok =\n        ~origins.indexOf(parts.hostname + ':' + parts.port) ||\n        ~origins.indexOf(parts.hostname + ':*') ||\n        ~origins.indexOf('*:' + parts.port);\n      if (!ok) this.log.warn('illegal origin: ' + origin);\n      return ok;\n    } catch (ex) {\n      this.log.warn('error parsing origin');\n    }\n  }\n  else {\n    this.log.warn('origin missing from handshake, yet required by config');\n  }\n  return false;\n};\n\n/**\n * Handles an incoming packet.\n *\n * @api private\n */\n\nManager.prototype.handlePacket = function (sessid, packet) {\n  this.of(packet.endpoint || '').handlePacket(sessid, packet);\n};\n\n/**\n * Performs authentication.\n *\n * @param Object client request data\n * @api private\n */\n\nManager.prototype.authorize = function (data, fn) {\n  if (this.get('authorization')) {\n    var self = this;\n\n    this.get('authorization').call(this, data, function (err, authorized) {\n      self.log.debug('client ' + authorized ? 'authorized' : 'unauthorized');\n      fn(err, authorized);\n    });\n  } else {\n    this.log.debug('client authorized');\n    fn(null, true);\n  }\n\n  return this;\n};\n\n/**\n * Retrieves the transports adviced to the user.\n *\n * @api private\n */\n\nManager.prototype.transports = function (data) {\n  var transp = this.get('transports')\n    , ret = [];\n\n  for (var i = 0, l = transp.length; i < l; i++) {\n    var transport = transp[i];\n\n    if (transport) {\n      if (!transport.checkClient || transport.checkClient(data)) {\n        ret.push(transport);\n      }\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Checks whether a request is a socket.io one.\n *\n * @return {Object} a client request data object or `false`\n * @api private\n */\n\nvar regexp = /^\\/([^\\/]+)\\/?([^\\/]+)?\\/?([^\\/]+)?\\/?$/\n\nManager.prototype.checkRequest = function (req) {\n  var resource = this.get('resource');\n\n  var match;\n  if (typeof resource === 'string') {\n    match = req.url.substr(0, resource.length);\n    if (match !== resource) match = null;\n  } else {\n    match = resource.exec(req.url);\n    if (match) match = match[0];\n  }\n\n  if (match) {\n    var uri = url.parse(req.url.substr(match.length), true)\n      , path = uri.pathname || ''\n      , pieces = path.match(regexp);\n\n    // client request data\n    var data = {\n        query: uri.query || {}\n      , headers: req.headers\n      , request: req\n      , path: path\n    };\n\n    if (pieces) {\n      data.protocol = Number(pieces[1]);\n      data.transport = pieces[2];\n      data.id = pieces[3];\n      data.static = !!this.static.has(path);\n    };\n\n    return data;\n  }\n\n  return false;\n};\n\n/**\n * Declares a socket namespace\n *\n * @api public\n */\n\nManager.prototype.of = function (nsp) {\n  if (this.namespaces[nsp]) {\n    return this.namespaces[nsp];\n  }\n\n  return this.namespaces[nsp] = new SocketNamespace(this, nsp);\n};\n\n/**\n * Perform garbage collection on long living objects and properties that cannot\n * be removed automatically.\n *\n * @api private\n */\n\nManager.prototype.garbageCollection = function () {\n  // clean up unused handshakes\n  var ids = Object.keys(this.handshaken)\n    , i = ids.length\n    , now = Date.now()\n    , handshake;\n\n  while (i--) {\n    handshake = this.handshaken[ids[i]];\n\n    if ('issued' in handshake && (now - handshake.issued) >= 3E4) {\n      this.onDisconnect(ids[i]);\n    }\n  }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":22106}]],"length":22106}
